# -*- coding: utf-8 -*-
"""OhioQuarterly.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IBLIYM9kc682bSHX0Di2QcXopPA9Xna0

Upload Dataset from local drive
"""

from google.colab import files
uploaded = files.upload()

"""1. Read the dataset by passing it as a parameter to the read_csv() in pandas to get the dataframe."""

import pandas as pd
df = pd.read_csv("/content/OhioQuar.csv")
print(df)

"""Crosscheck column names"""

print(df.columns)

"""2. To calculate the annual data for oil, gas, and brine based on the API_WellNumber, we can group the data by the API_WellNumber and then sum the quarterly production values for each category.

Here's the code to perform the required calculation:

This code will group the DataFrame df by the 'API_WellNumber' column and calculate the sum of 'OIL', 'GAS', and 'BRINE' for each well. The resulting DataFrame, annual_data, will contain the annual production values for each category.
"""

annual_data = df.groupby('API_WellNumber')['OIL', 'GAS', 'BRINE'].sum()
print(annual_data)

"""3. To load the calculated annual data into a local SQLite database using Python, we need to install the sqlite3 package.

This code creates a table called annual_data in the database with columns for API_WellNumber, OIL, GAS, and BRINE. It then iterates over the annual data DataFrame and inserts the values into the table.
"""

import sqlite3

# Connect to the SQLite database
conn = sqlite3.connect('Ohio_Database.db')  # Replace 'your_database_name.db' with the desired database name

# Create a cursor object to execute SQL commands
cursor = conn.cursor()

# Create a table for the annual data
cursor.execute('''
    CREATE TABLE IF NOT EXISTS annual_data (
        API_WellNumber INTEGER PRIMARY KEY,
        OIL INTEGER,
        GAS INTEGER,
        BRINE INTEGER
    )
''')

# Insert the annual data into the table
for index, row in annual_data.iterrows():
    api_wellnumber = int(index)
    oil = row['OIL']
    gas = row['GAS']
    brine = row['BRINE']
    
    cursor.execute('INSERT OR IGNORE INTO annual_data (API_WellNumber, OIL, GAS, BRINE) VALUES (?, ?, ?, ?)',
               (api_wellnumber, oil, gas, brine))

# Commit the changes and close the connection
conn.commit()
conn.close()

"""4. Now as we run the Flask app, we can send a GET request to http://localhost:8080/data?well=34059242540000, and it will return the annual data for the specified well in the JSON format as mentioned in your example."""

from flask import Flask, jsonify, request
import sqlite3

# Create a Flask app
app = Flask(__name__)

# Define the route for retrieving annual data
@app.route('/data', methods=['GET'])
def get_annual_data():
    # Extract the well API_WellNumber from the query parameters
    well_api_number = request.args.get('well')
    
    # Connect to the SQLite database
    conn = sqlite3.connect('Ohio_Database.db')

    # Create a cursor object to execute SQL commands
    cursor = conn.cursor()

    # Retrieve the annual data for the specified well API_WellNumber
    cursor.execute("SELECT OIL, GAS, BRINE FROM annual_data WHERE API_WellNumber = ?", (well_api_number,))
    result = cursor.fetchone()

    # Close the connection to the database
    conn.close()

    # If the well API_WellNumber is found in the database, return the annual data
    if result is not None:
        oil, gas, brine = result
        annual_data = {
            'oil': oil,
            'gas': gas,
            'brine': brine
        }
        return jsonify(annual_data)
    
    # If the well API_WellNumber is not found in the database, return an error message
    error_message = {
        'error': f"No annual data found for well API_WellNumber {well_api_number}"
    }
    return jsonify(error_message), 404

# Run the Flask app on port 8080
if __name__ == '__main__':
    app.run(port=5000)